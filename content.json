{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"About-SQLServer2","slug":"about-SQLServer2","date":"2019-07-05T11:26:24.000Z","updated":"2019-07-23T05:45:03.838Z","comments":true,"path":"2019/07/05/about-SQLServer2/","link":"","permalink":"http://yoursite.com/2019/07/05/about-SQLServer2/","excerpt":"","text":"续 about-SQLServer由于上一张博客信息量过大，所以这次是上一张的延续。 首先来回顾下上一张博客学到的内容 索引（创建、删除、查看） sql的执行顺序select…from…where..group by …多行函数计算having…计算所有的表达式order by.. 约束 关于修改表格字段的sql语句alter table …add/change/modify..删除表格drop table if exists 表名; 关于修改表格数据的sql语句insert into..values( );delete from..whereupdate…set…where..select..from..select*from….where.. where子句 sql注入攻击和防止注入攻击1’ or ‘1’ = ‘11’’ or ‘’1’’ = ‘’1 字符串函数、数字函数、null值函数、加密函数、多行函数 group by 制定字段分组having子句，对分组函数过滤 接下来我们就来讲一些中等级别的sql操作。 一、子查询（嵌套查询）这是一般项目中最常用到的，也是非常重要的知识点1.条件子查询（一个查询的结果作另一个查询的过滤条件） select..from… where a=(select…) //单值用 = 、 &lt;&gt; 、 &gt; 、 &lt; //多值用 in 、&gt;all 、 &gt;any //多列子查询： where(a,b)=(select x,y from..) where(a,b) in (select x,y from..)注意了，因为后面的代码都是比较繁琐的，我建议先打开记事本，在记事本里预先写好代码了，再往cmd里运行如：（1）拿最低工资的所有员工 先求最低工资，用最低工资查询员工 select min(salary) from 表; select id,name,salary from 表 where salary=( select min(salary) from 表 ); （2）工资低于平均工资的员工 先求平均工资，用平均工资，过滤员工 select avg(salary) from 表; select id, name, salary from 表 where salary&lt;( select avg(salary) from employees ) order by salary desc; （3）只有一个人的部门中的员工 先分组查询只有一人的部门id，再用部门id，过滤员工 select department_id from 表 where department_id is not null group by department_id having count(*)=1; select id,name,salary,department_id from 表 where department_id in( select department_id from 表 where department_id is not null group by department_id having count(*)=1 ); （4）每个部门中，拿最低工资的员工 先分组求最低工资，再用部门id和工资值，过滤员工 select department_id,min(salary) from 表 where department_id is not null group by department_id; select id,name,department_id,salary from 表 where (department_id,salary) in( select department_id,min(salary) from 表 where department_id is not null group by department_id ) order by department_id;2.from子查询 行内视图（从一个查询的结果中，再查询。mysql行内视图，必须起别名） select … from (select …) t如：（1）求手下人数最多的主管id 先分组求人数，然后获得最大人数值，再重新分组求人数，用人数过滤主管id select manager_id,count(*) c from 表 where manager_id is not null group by manager_id; select max(c) from ( select manager_id,count(*) c from 表 where manager_id is not null group by manager_id ) t; select manager_id from 表 where manager_id is not null group by manager_id having count(*)=( select max(c) from ( select manager_id,count(*) c from 表 where manager_id is not null group by manager_id ) t ); //再根据上面的查询，再进一步，查询这个主管的信息 select id,name,salary from 表 where employee_id=( select manager_id from 表 where manager_id is not null group by manager_id having count(*)=( select max(c) from ( select manager_id,count(*) c from 表 where manager_id is not null group by manager_id ) t ) ); （2）求平均工资最低的岗位员工信息 先求每个岗位的平均工资，再求最小平均工资，然后求最小平均工资的岗位，用岗位过滤员工 select job_id,avg(salary) a from 表 group by job_id; //求平均工资 select min(a) from ( select job_id,avg(salary) a from 表 group by job_id ) t; //求最小平均工资 select job_id,avg(salary) a from 表 group by job_id having a=( select min(a) from ( select job_id,avg(salary) a from 表 group by job_id ) t ); //求最小平均工资的岗位 select id,name,salary,job_id from 表 where job_id in( select job_id from 表 group by job_id having avg(salary)=( select min(a) from ( select job_id,avg(salary) a from 表 group by job_id ) t ) ); //用岗位再求出员工信息3.字段子查询（子查询的结果， 作为外面查询结果的一列） select a,b,c,(select …) c from …如： select id,name,salary, //注意了，这里有个逗号，是查询结果 (select avg(salary) from 表) avg_sal from 表; 二、Union联合查询将多个查询的结果，组合成一个查询结果 (select …) union (select …)注意了，字段列表数量必须相同union 去除重复行union all 不去除重复行如：（1）最早入职的5人，和最晚入职的5人 (select id,name,salary,hire_date from 表 order by hire_date limit 5) union (select id,name,salary,hire_date from 表 order by hire_date desc limit 5) order by hire_date;三、多表连接查询 直接莽过来就是代码吧如：（1）查询员工信息，附带显示部门名 select e.id,e.name,e.salary, d.department_id,d.department_name from employees e, departments d where e.department_id=d.department_id; （2）查询部门和部门所在的城市 select d.department_id,d.department_name, l.city from departments d, locations l where d.location_id=l.location_id; （3）’Finance’财务部的人数 select count(*) from employees e, departments d where e.department_id=d.department_id and d.department_name=’Finance’; 1.外连接内连接：只查询符合连接条件的数据外连接：连接条件以外的数据，也要查询出来 非标准sql表连接语法，不同数据库，外连接语法不同 a.c1 = b.c2 a.c1 = b.c2 a.c1(+) = b.c2 a.c1 = b.c2(+) mysql 没有非标准外连接语法 mysql 只能用标准语法做外连接查询 2.sql标准表连接语法（1）内连接 select … from a inner join b on(连接条件) （2）左外连接 select … from a left outer join b on(连接条件) （3）右外连接 select … from a right outer join b on(连接条件) （4）全外连接(mysql是不支持的) select … from a full outer join b on(连接条件)如：（1）107个员工，显示主管名 select e1.employee_id,e1.first_name, e1.salary,e2.first_name mgr from employees e1 left join employees e2 on(e1.manager_id=e2.employee_id); （2）107个员工，显示部门名，城市 select e.employee_id,e.first_name, e.salary, d.department_name,l.city from employees e left join departments d on(e.department_id=d.department_id) left join locations l //第三张表左外连接 on(d.location_id=l.location_id); 四、事务（数据库管理系统执行过程中的一个逻辑单位）1.开始事务 start transaction; begin; //数据增删改操作，不直接修改数据表，而是在日期文件中记录修改2.提交事务 commit; //将日志中记录的修改操作，永久保存到数据表，然后日志文件清空3.回滚事务 rollback; //日志文件清空如：","categories":[],"tags":[]},{"title":"about SQLServer","slug":"about-SQLServer","date":"2019-07-04T03:31:23.000Z","updated":"2019-07-05T10:49:25.766Z","comments":true,"path":"2019/07/04/about-SQLServer/","link":"","permalink":"http://yoursite.com/2019/07/04/about-SQLServer/","excerpt":"","text":"关于数据库知识点的整理搞开发的人员对于数据库的管理必须要精通，尤其是大数据开发这块，可能很多时候弄了半天才发现，原来只是某个sql语言写错了在这里我将我学到的数据库基础都整理出来，希望能够在日后的学习中，省去一大半查资料的时间 &nbsp;&nbsp;我用的是MariaDB，所以可能会与MySql有所出入，但大体是不会有任何影响的。无非就是MySql中设置default时，必须用字母，但MaraiDB中可以用中文MaraiDB使用XtraDB来代替MySql的InnoDB。网上下载MariaDB会附带下载可视化工具HeiDiSQL，我建议用MariaDB，别的可视化工具也行，我用的是navicat Premium 12 数据库基础基础中的基础 首先需要配置环境变量，将MariaDB的bin目录打开，复制路径，粘贴到我的电脑-&gt;属性-&gt;高级设置-&gt;环境变量-&gt;第一栏新建。 完成之后，打开cmd mysql -uroot -proot 连接数据库 末尾不需要分号 show databases;/show schemas; 查看数据库列表 use 数据库名; 进入某数据库 show tables; 查看数据库列表 show create table 表\\G 查看建表语句 create user ‘用户名‘@’localhost’ identified by ‘密码’; 创建可以远程连接的数据库，这是创建用户的代码，由 ‘用户名‘@’ip地址’组合 这 里我的用户名是deajowlo，ip地址为localhost grant all privileges on . to ‘用户名‘@’ip地址; 对用户授权，这里对用户授了所有表的所有权限。也可以只给一些权限，如：grant select,insert,drop on . to ‘用户名‘@’ip地址; flush privileges; 授权后刷新授权表 exit; 退出数据库 重新远程连接mysqlmysql -u用户名 -p密码 -h地址 \\q 退出 mysql -uroot -proot 以root身份重新连接 create database 数据库名 charset utf8; 创建数据库 show create databases 数据库名\\G 查看建数据库的代码 alter databases 数据库名 charset gbk; 只能修改字符编码 drop database 数据库名; 删除数据库 show variables like ‘%datadir%’; 查看数据库目录 like ‘%datadir%’是模糊查询含有datadir字段的数据库目录 约束类型：primary key 主键约束；foreign key 外键约束；unique 唯一；check 检查； not null 非空 一、如何优化数据库查询为了优化用户体验，增加数据库的稳定性（低效的查询会引发很多数据库问题），避免网页出现访问错误（timeout产生的错误、查询慢引发的页面无法加载、阻塞造成数据库无法提交），通常我们会对数据库进行优化 避免全表扫描。 首先考虑where和orderby涉及的列上建立索引 避免在where语句中使用 != 或 &lt;&gt;操作符 避免在where语句中对字段进行null值判断 避免在where语句中使用or来连接条件 select id from 表名 where name like “%abc%” 这样的查询语句也会导致全表扫描，可考虑全文检索提高效率 慎用in 和 not in ，可用exists代替in 避免在where语句中对字段进行表达式和函数操作 二、索引 为什么要创建索引假设有未创建索引的表t1,t2,t3，分别只包含c1，c2，c3列，每张表有1000行数据，让你做对应值相等的查询用select c1,c2,c3 from t1,t2,t3 where c1=c2 and c1=c3查询结果就是1000行，每行3个相等值，没有索引的话，可能的结果就是100010001000但若对表建立索引，就可以从表t1的第一行查，使用t2的索引，可定位到t2=t1的行，然后同样用在t3上，这样重复下去，只需要遍历t1的行就可以了。 建索引原则要在大数据量的表上建立在where子句或连接条件上常引用的列上建立需要多表查询时建立很少或不引用的字段和逻辑型字段，如男或女、是或否 等不建立 创建索引（1）可在执行create table 语句时创建 create table 表名( 字段名 字段类型 index/primary key/unique )engine=innodb charset=utf8;（2）也可单独使用create index &lt;font color=#DA70D6&gt;create index 可对表增加普通索引或unique索引,不能创建primary key索引&lt;/font&gt; create index 索引名 on 表名(字段) 或 create unique index on 表名(字段)（3）也可以单独使用alter table 来创建普通索引、unique、primary key索引 alter table 表名 add index 索引名(字段) 或 alter table 表名 add unique(字段) 或 alter table 表名 add primary key(字段)（4）删除索引 drop index 索引名 on 表名 或 alter table 表名 drop index 索引名 或 alter table 表名 drop primary key/unique（5）查看索引 show index from 表名 或 show keys from 表名（6）索引与约束的区别 索引 约束 对数据库表中一列或多列的值进行排序的一种结构 对表中的数据进行进一步的限制 增加数据库的存储空间 保证数据的正确性、有效性和完整性 使插入、修改数据的时间变多 定义数据库中的数据必须符合的某些属性 可常驻内存进行处理 可以被当做数据库对象来处理 在数据库条件查询时速度很慢该如何优化: 建索引 减少表关联 优化sql，尽量让sql用索引定位，不要全表查询 简化查询字段，没有的字段不要，尽量返回少量数据 利用分页查询减少返回的数据量 三、分页查询分页查询方式： select distinct 字段 from 表名 order by 字段 desc limit 0，10; select distinct 字段 from 表名 order by 字段 desc limit 0，10; distinct 表示去重，这种方式易丢失数据 select distinct 字段 from 表 order by 字段 desc limit 10; select distinct 字段 from 表 where 字段 &lt; $last_min_字段 order by 字段 desc limit 10; $last_min_字段表示最后一个字段，这种方式没有命中唯一索引，而是一般索引，需要group by select 字段 from 表 group by 字段 order by 字段 desc limit 10; select 字段 from 表 group by 字段 having 字段 &lt; $last_min_字段 order by 字段 desc limit 10; 四、一些关于表的基础sql语句 添加字段： alter table 表 add 字段 first; //first指添加字段到第一个 alter table 表 add 字段 after 某字段; alter table 表 add (字段1，字段2); 修改字段： alter table 表 modify 字段 字段新类型 新内容; 调整字段顺序： alter table 表 modify 字段 字段类型 first; //将字段放在第一个 alter table 表 modify 字段 字段类型 after 某字段; //将字段放在某字段后 删除字段： alter table 表 drop 字段; 删除表： alter table if exists 表; 插入数据： insert into 表 values(内容); 删除数据： delete from 表 where 字段=” “; 修改数据： update 表 set 字段1=” “,字段2=” “ where 字段3=” “; 查询字段： select 字段 from 表; select 字段1,字段2 from 表; select * from 表 where 字段要求; 添加约束：（1）添加主键约束alter table 表 add primary key(字段1，字段2); //这里的举例是用字段组合做主键，双主键，一般不用，大部分都只是一个主键（2）添加外键约束create table 表1 (字段1 字段类型 primary key auto_increment); //primary key auto_increment表示自增主键create table 表2 (字段2 字段类型，foreign key(字段2) reference 表1(字段1));或alter table 表2 add foreign key(字段2) reference 表1(字段1);（3）字段唯一组合约束unique key(字段1，字段2); 默认用default注释用comment 自表数据复制insert into 表(字段) select 字段 from 表; //把查询结果数据批量插入到一张表 查询结果创建成表create table 表2asselect 字段1，字段2 from 表1;select * from 表2; 按指定字段排序，并只修改前几行update 表 set 字段1=” “,字段2=” “order by alimit 5; 指定字段排序，并删除前几行delete from 表order by alimit 5; 通配符_ 单字符% 多字符\\转义 weher子句（1）id=10; id是10id&lt;&gt;10; id不是10 id&lt;10; id小于10 id between 2 and 10; id在2和10之间 id in(2,4,6); id是2，4，6的 id is null; id是null值 name like &apos;%en%&apos;; 名字包含en name like &apos;_en%&apos;; 名字第三、四个字符是en name like &apos;en%&apos;; 名字以en开头 id not between 2 and 10; id小于2或id大于5的 id not in(2,4,6); id不是2，4，6的 id is not null; id不是空 name not like &apos;%en%&apos;; 排除名字中包含en的 id=10 or name like &apos;%en&apos;; id是10的或者名字后缀为en的 id=10 or (id=5 and salary&lt;=2500); id是10或者id是5且工资小于2500的人 五、mysql的数据类型1.关于数字的 unsigned 无符号，只有正数 zerofill 在前面补0 tinyint 1字节 smallint 2字节 int 4字节 int(5) 查询结果被显示时，不足5位，按5位显示，配合参数 zerofill 参数，可以在前面补0不足5位 bigint 8字节 float 4字节，单精度 double 8字节，双精度 decimal(m,n) 定点数，固定长度的小数位；整数m-n位，小数n位，总共m位 decimal(6,4) 整数位2位，小数位4位，一共6位 2.关于字符串的 char 定长字符串，最长不能超过255个字符 char(6) 定长6个字符， 超过6位，可能出错，也可能截断， 不足6位，在后面添加空格 varchar 变长字符串，最大65535个字节 varchar(6) 如果指定的最大长度，在255个字节内，在前面会加1个字节，表示字符串的字节长度 最大长度大于255，在前面加2个字节，表示字符串的字节长度 char和varchar区别： char效率高 varchar效率低，读取时，先读取长度值，再取字符串 text 65535个字节 latin1 字符数量：65535 gbk 65535/2 个字符 utf8 65535/3 个字符 3.关于日期的 datetime 年月日时分秒 date 年月日 time 时分秒 timestamp 时间戳 时间范围，只到2038年 第一个timestamp字段，会在修改这行数据时，自动修改成系统当前时间 六、单引号的作用 单引号转义：‘a’b’ 错误‘a’’b’ 正确，中间的两个单引号，前一个是转义符，最后的输出条件是a’b sql注入攻击：1’ or ‘1’ = ‘1 单引号是改变了sql数据结构 select * from 表 where username=’xxx’ and password=’1’ or ‘1’ = ‘1’; 防止sql注入攻击：1’’ or ‘’1’’ = ‘’1 select * from 表 where username=’xxx’ and password=’1’’ or ‘’1’’ = ‘’1’; 七、Order Byselect ….from….where…1.order by a 按a字段升序排列2.order by a,b 按a字段升序排列，a相同，按b升序排3.order by a desc 按a字段降序排列4.order by a desc, b asc 按a字段降序排列，b字段升序排列 八、字段别名在where中不能用，order by 中能用字段别名是给字段或者表达式起的，表名也可以有别名 select id,name,salary salary12 sal from 表 where salary12 &gt;=1000 order by sal desc; 九、mysql的函数1. 字符串函数写在where子句中char_length(‘ ‘) - 字符数 char_length(first_name)=char_length(first_name);length(‘ ‘) - 字节数 concat(‘a’,’b’,’cde’,’fff’) - 字符串连接lpad(‘准备填充的字符串’, 填充后字符串长度, ‘填充字符串，用来粘贴到准备填充的字符串的左边，可选参数’) - 左侧填充，指定长度比源字符串少，相当于leftrpad(‘abc’, 8, ‘*’) - 右侧填充，指定长度比源字符串少，相当于left select concat(lpad(first_name,20,’ ‘),’ ‘,last_name) from 表 order by first_name;concat_ws(‘;’,’abc’,’def’,’ggg’) - 用分隔符连接字符串 instr(‘abcdefgdef’,’def’) - 返回第一个子串的位置，从1开始，找不到返回0 locate(‘abc’, ‘—abc—abc—abc-‘) - 返回第一个子串的位置，从1开始，找不到返回0locate(‘abc’, ‘—abc—abc—abc-‘,5) - 从指定位置向后找 insert(‘abcdefghijkl’,2, 9, ‘—‘) - 用子串取代从2位置开始的9个字符 lower(‘AdFfLJf’) - 变为小写upper(‘AdFfLJf’) - 变为大写 left(‘AdFfLJf’,3) - 返回最左边的三个字符right(‘AdFfLJf’,3) - 返回最右边的三个字符substring(‘abcdefghijklmn’, 3) - 从3位置开始的所有字符substring(‘abcdefghijklmn’, 3, 6) - 从第3个字符开始取6位 substring(first_name,1,1)=substring(last_name,1,1); //first_name和last_name首字母相同的 left(first_name,1)=left(last_name,1) //此例与上述等式相同，返回最左边的第1个字符 trim(‘ a bc ‘) - 去除两端空格 repeat(‘abc’, 3) - 重复三遍abc replace(‘Hello MySql’,’My’,’Your’) - 子串替换 email&lt;&gt;concat(left(first_name,1), replace(last_name,’ ‘,’ ‘)); //email不符合规则的话，first_name首字母连接last_namereverse(‘Hello’) - 翻转字符串 space(10) - 返回10个空格 2. 数字函数ceil(3.94) - 向上取整 floor(3.94) - 向下取整 round(673.4974) - 四舍五入 round(673.4974, 2) - 四舍五入到小数点后2位 round(673.4974, -2) - 四舍五入到百 truncate(234.39, 1) - 舍去至小数点后1位，必须指定位数 format(391.536, 2) - 数字格式化为字符串，###,###.###，四舍五入，第二个参数为小数位数 format(now(),’%Y_%M_%D’)rand() - 随机浮点数,[0,1) select *from 表 order by rand(); 3. 日期函数日期字符串格式符合mysql的默认格式 ‘2018-3-15’，可以与日期类型数据之间自动转换 now() 返回当前的日期和时间 curdate() 返回当前的日期curtime() 返回当前的时间 date(时间) 提取日期或日期/时间表达式的日期部分time(时间) 提取日期或日期/时间表达式的时间部分 extract(字段 From 日期) 返回日期/时间的单独部分 字段的合法值： microsecond second_microsecond second minute_microsecond minute minute_second hour hour_microsecond hour_second hour_minute day day_second day_minute day_hour week month quarter year year_month dd DATE_ADD(日期, interval 数量 字段) 给日期添加指定的时间间隔 字段的合法值同上 DATE_SUB(日期, interval 数量 字段) 从日期减去指定的时间间隔 DATEDIFF(日期1, 日期2) 返回两个日期之间的天数 DATE_FORMAT(日期, 格式) 用不同的格式显示日期/时间 格式字符： %Y-%m-%d %H:%i:%s %d/%m/%Y %Y年%m月%d日 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 LAST_DAY(日期) - 返回当月最后一天 4. null值函数1.ifnull(1, 2) 1是null,取2 1不是null,就取1 select id,name,salary, salary12(1+ifnull(字段1,字段2)) sal from employees;2.coalescs(1,2,3,4,5,6,7….) 获取第一个非空值 5. 加密函数md5() 单向加密，不能解密 任何数据，加密成32位16进制字符 一般用来加密保存用户密码 sha() 单向加密，不能解密 任何数据，加密成40位16进制字符 insert into user(username,password) values (&apos;用户名1&apos;,md5(&apos;用户密码1&apos;)), (&apos;用户名2&apos;,md5(&apos;用户密码2&apos;));6.分支（1）if(1,2,3) 1是真，返回2 ； 1是假，返回3 （2）case when 条件1 then …. when 条件2 then …. else … end （3）case 字段或表达式 when 值1 then …. when 值2 then …. else … end 7. 多行函数（聚合函数）sum() avg() max() min() count() （1）不能和其他普通字段一起查询 select avg(salary),employee_id,first_name from 表; 其他数据库会禁止直行，mysql可以执行，只是把第一条数据显示出来 select sum(salary),avg(salary), max(salary),min(salary), count(salary) from 表;（2）多行函数可以一起查询，并且忽略null值 （3）count(a)对指定字段的值计数，重复值会重复计数，可用distinct去除重复 select count(distinct job_id) from 表; //有多少工作岗位（4）count(*) 计算行数 8. group by 分组计算多行函数按指定字段，相同的值，分组计算 group by a， 按a字段相同值分组 group by a,b， 按a,b字段组合相同值分组 只有求多行函数时，才用group by 分组字段，可以和多行函数一起查询 每个部门中，每个岗位的人数，按人数排序 select department_id,job_id,count(*) c from 表 where department_id is not null group by department_id,job_id order by c; 9. having子句，对分组函数结果过滤 where 最先执行，只能过滤普通条件 having 分组计算完多行函数后，执行过滤。必须在group by 后面 （1）只有一个手下的主管 select manager_id, count(*) c from 表 where manager_id is not null group by manager_id having c=1; （2）平均工资大于8000的工作岗位 select job_id,avg(salary) s from 表 group by job_id having s&gt;8000 order by s desc;总结 sql语句执行顺序from 子句 ，组装不同数据源的数据（如各种表格等等）where ，指定条件对记录筛选group by ，将数据划分为多个组使用聚合函数计算的sql语句having ，筛选分组计算所有的表达式order by ，对结果集排序 数据库执行计划sql语句发送到数据库，要翻译成执行计划，利用执行计划执行实现数据库在执行完全一样的sql语句时会重用相同的执行计划有 ？ 参数的sql语言会重用相同的执行计划","categories":[],"tags":[]},{"title":"The First Day of DEAJOWLO Using node js create blog","slug":"The-First-Day-of-DEAJOWLO-Using-node-js-create-blog","date":"2019-07-03T02:25:42.000Z","updated":"2019-07-04T03:22:47.879Z","comments":true,"path":"2019/07/03/The-First-Day-of-DEAJOWLO-Using-node-js-create-blog/","link":"","permalink":"http://yoursite.com/2019/07/03/The-First-Day-of-DEAJOWLO-Using-node-js-create-blog/","excerpt":"","text":"新建一个自己的博客并部署到github上首先下载node.js（就是两大js运行环境之一），然后在你要建本地博客的地方打开你的cmd（目前操作都是在windows环境下的）node -v查看node.js版本npm -v查看包管理器版本npm install -g cnpm –registry=http://registry.npm.taobao.org 这行代码是借助npm包管理器来指向cmpn淘宝镜像源，是下载速度快一点下载完后可输入cnpm和cnpm -v来查看cnpm和cnpm的版本号然后输入cnpm install -g hexo-cli意思是用cnpm来安装hexo博客框架，-g的意思就是全局安装输入hexo -v 来验证一下，会发现它是基于node的输入cd查看当前目录输入mkdir 博客文件名 （创建一个用来放你要做博客的文件，之后所有博客里的东西都是在这个文件里的，如果出错，可以直接删除文件重来）输入cd 博客文件名 ，进入这个文件然后用hexo来完成新建博客windows中可直接输入hexo init来初始化一个博客看到start blogging with hexo！就说明初始化完成。输入dir 可以查看生成的配置文件hexo s ，启动博客，结果会出现一个运行的本地端口，我生成在http://localhost:4000 可以在浏览器中输入该网址查看内容。打开浏览器即可看见它自动生成的博客，Hello World输入Ctrl+C退出，重新写一篇自己的文章。输入 hexo n “文章名” 生成一个新的博客，结果会出现这个博客文章的路径输入 cd 文章路径 （可查看）该文章 重点来了！因为我们是windows系统，它并不自带vim文本编辑器，但windows也很方便，在这里告诉大家一个简单的方法去文件夹里找到博客，用记事本或别的文本编辑器打开，如everedit等等然后将你要写的博客写进去，格式就是如下： 一级标题 === 内容 &lt;font color=red &gt;二级标题&lt;/font&gt; //可以设定颜色，大小size，字体font --- 内容即可。也可以在cmd里，输入notepad 博客文件路径 ，就可以直接打开记事本书写了。一般都是用markdown格式的语法，完成以后保存退出。输入cd （查询一下当前路径）回到blog文件夹输入cd ../.. （退两层路径）输入 hexo clean （清理缓存）输入hexo g （重新生成hexo文件）输入 hexo s （启动hexo）上面三条输入语言可通过输入 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 一起运行然后输入网址即可查看 具体的博客搭建已经完成，部署到github上有些人可能只有github的账号，其实gitlab和github是一样的。登录github，new repository 新建仓库输入repository name，一定要按照：你的用户名.github.io 后期也是在浏览器中输入这个地址才能访问你的博客description里可以随便写然后create repository之后的操作就和上述gitlab中的一样，都是在cmd中完成在blog目录下安装git的部署插件输入cnpm install hexo-deployer-git –save 这个过程按照网速来算，可能会有点慢，请耐心等待输入dir &amp;&amp; notepad _config.yml （查看文件并修改_config.yml文件）在最后的deploy:下输入 type: git repo: 你的仓库地址 branch: master保存退出输入hexo d （部署到我们的github上，d就是deploy）根据提示，输入用户名和密码然后去网页上刷新我们的仓库，就可以看到我们的成果了然后单独拿出我们的仓库名，在浏览器中访问，可能一开始无法打开，但是可以多刷新几次 换主题我用的是yilia主题1.先去下载这个主题输入 git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia用git下载yilia主题，并下载到themes文件夹下的yilia目录2.下载完成后查看输入 cd themes/3.输入 cd .. 回到上一层4.修改_config.yml文件一直找，找到theme:landscape,将landscape改为yilia5.重新部署输入 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s &amp;&amp; hexo d6.具体的yilia主题内容还需要自己修改，因为这只是个模板 技术难点1.乱码我在在博客文章里的内容，在网页上打开来是乱码，但是在文件里是正常的解决： 重新打开博客文件，另存为，将保存编码改为UTF-8 2.显示不出我的博客文章标题打开浏览器，发现网页右边显示（notitle）但是我的md文件里明明那个设置了title解决： 删除博客，重新生成一份新的 3.单独拿仓库名访问时报404（无法查询页面）起初我以为是我的热点信号不好，后来看网上说，这是要git用户名和git的账号名一样才能查看，其实并不是这样我发现了我并没有设置我这个博客的访问地址，我只是设置了它的仓库名，于是我按照提示设置了访问地址解决： 格式如下，输入 http://你的用户名.github.io 这才是正确的格式 windows和linux中的一些命令区别 linux windows qwd cd sudo（用管理员的命令来执行） 可直接用 要执行的exe init ls dir","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-02T11:11:55.708Z","updated":"2019-07-02T11:11:55.708Z","comments":true,"path":"2019/07/02/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}